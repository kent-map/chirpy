<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Viewer</title>

  <!-- OpenSeadragon -->
  <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0.1/build/openseadragon/openseadragon.min.js"></script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      /* background: #111; */
    }

    /* Wrap includes BOTH viewer + caption area */
    #wrap {
      height: 100%;
      display: grid;
      grid-template-rows: 1fr auto;
      position: relative;
      /* for bottom-right hotspot */
    }

    #osd {
      width: 100%;
      height: 100%;
      background: #111;
    }

    /* Chirpy-like caption (muted, centered, no banner) */
    #caption {
      display: none;
      text-align: center;
      font-size: 0.8em;
      line-height: 1.4;
      margin-top: 0.25rem;
      padding: 0;
      color: #6d6c6c;
      background: transparent;
      word-break: break-word;
    }

    @media (prefers-color-scheme: dark) {
      #caption {
        color: rgba(255, 255, 255, 0.55);
      }
    }

    /* Error banner */
    #msg {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px 12px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
      background: rgba(180, 40, 40, 0.9);
      display: none;
      z-index: 1000;
    }

    code {
      background: rgba(255, 255, 255, .1);
      padding: 0 4px;
      border-radius: 4px;
    }

    /* Bottom-right hover hotspot + tooltip */
    #ar-hotspot {
      position: absolute;
      right: 10px;
      bottom: 10px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .10);
      border: 1px solid rgba(255, 255, 255, .18);
      z-index: 50;
      pointer-events: auto;
    }

    #ar-tip {
      position: absolute;
      right: 0;
      bottom: 26px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(0, 0, 0, .80);
      color: rgba(255, 255, 255, .90);
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      white-space: nowrap;
      transform: translateY(4px);
      opacity: 0;
      transition: opacity 120ms ease, transform 120ms ease;
      pointer-events: none;
    }

    #ar-hotspot:hover #ar-tip {
      opacity: 1;
      transform: translateY(0);
    }

    #drawing-overlay {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
      pointer-events: none;
    }

    .box {
      position: absolute;
      border: 2px solid red;
      box-sizing: border-box;
      z-index: 20;
    }

    .box .handle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: white;
      border: 1px solid red;
      box-sizing: border-box;
      z-index: 21;
    }

    .box .handle.nw {
      top: -4px;
      left: -4px;
      cursor: nw-resize;
    }

    .box .handle.ne {
      top: -4px;
      right: -4px;
      cursor: ne-resize;
    }

    .box .handle.sw {
      bottom: -4px;
      left: -4px;
      cursor: sw-resize;
    }

    .box .handle.se {
      bottom: -4px;
      right: -4px;
      cursor: se-resize;
    }

    .copy-icon {
      position: absolute;
      width: 20px;
      height: 20px;
      line-height: 20px;
      text-align: center;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      z-index: 22;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="msg"></div>

  <div id="wrap">
    <div id="osd"></div>
    <canvas id="drawing-overlay"></canvas>

    <!-- bottom-right hover hotspot + tooltip (aspect ratio of entire iframe, incl caption) -->
    <div id="ar-hotspot" aria-label="Iframe aspect ratio">
      <div id="ar-tip"></div>
    </div>

    <div id="caption"></div>
  </div>

  <script type="module">
    import 'https://cdn.jsdelivr.net/npm/js-md5@0.8.3/src/md5.min.js'

    const params = new URLSearchParams(location.search);

    let src = params.get("src");
    const captionStr = params.get("caption");
    const cover = params.get("cover") === "1"; // viewer expects cover=1
    const regionStr = params.get("region");        // "full" | "x,y,w,h" | "pct:x,y,w,h"
    const rotateStr = params.get("rotate");        // "0" | "90" | "!90" etc
    const max = ['', 'true', '1'].includes(params.get("max"));

    const msgEl = document.getElementById("msg");
    const capEl = document.getElementById("caption");

    let imageAspect;

    function showMsg(html) {
      msgEl.innerHTML = html;
      msgEl.style.display = "block";
    }

    if (!src) {
      showMsg(`Missing <code>?src=</code> parameter.`);
      throw new Error("Missing src");
    }

    const mwImage = (mwImg, width) => {
      width = width | 0
      // Converts Wikimedia commons image URL to a thumbnail link
      mwImg = mwImg.split('/').pop().replace(/^wc:/, '').replace(/Special:FilePath\//, 'File:').split('File:').pop().replace(/^\d+px-/, '')
      mwImg = decodeURIComponent(mwImg).replace(/ /g, '_')
      const _md5 = md5(mwImg)
      const extension = mwImg.split('.').pop()
      let url = `https://upload.wikimedia.org/wikipedia/commons${width > 0 ? '/thumb' : ''}`
      url += `/${_md5.slice(0, 1)}/${_md5.slice(0, 2)}/${mwImg}`
      if (width > 0) {
        url += `/${width}px-${mwImg}`
        if (extension === 'svg') {
          url += '.png'
        } else if (extension === 'tif' || extension === 'tiff') {
          url += '.jpg'
        }
      }
      return url
    }

    if (src.indexOf('wc:') === 0 || src.indexOf('wikimedia.org') > -1 || (src.indexOf('wikipedia.org') > -1 && props.src.indexOf('/media/File:') > -1)) {
      src = mwImage(src, max ? -1 : 1200)
    }

    window.addEventListener('message', (event) => {
      if (!event.data) return;
      let eventData = JSON.parse(event.data)
      let action = eventData.action?.toLowerCase()
      let text = eventData.text
      let args = eventData.args
      console.log(action, args);
      if (action === 'zoomto') {
        zoomto(args[0], text)
      }
    });



    /**
    * Expand a bounding box to twice its width and height,
    * centering the original box inside the new one.
    *
    * @param {{x:number, y:number, w:number, h:number}} box
    *   The original bounding box.
    * @param {'round'|'floor'|'ceil'} [rounding='round']
    *   How to round the computed coordinates.
    * @returns {{x:number, y:number, w:number, h:number}}
    *   The expanded, centered bounding box.
    */
    function expandBox(box, rounding = 'round') {
      let scale = 1.8;
      // New dimensions
      const newW = box.w * scale;
      const newH = box.h * scale;

      // Center of the original box
      const cx = box.x + box.w / scale;
      const cy = box.y + box.h / scale;

      // Compute top-left of the expanded box so it's centered on (cx,cy)
      let x = cx - newW / scale;
      let y = cy - newH / scale;

      // Apply rounding
      if (rounding === 'floor') {
        x = Math.floor(x);
        y = Math.floor(y);
      } else if (rounding === 'ceil') {
        x = Math.ceil(x);
        y = Math.ceil(y);
      } else {
        x = Math.round(x);
        y = Math.round(y);
      }

      return { x, y, w: newW, h: newH };
    }

    /**
    * Place a padded, semiâ€transparent text caption under a box,
    * with fully opaque text.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box   Imageâ€pixel bbox
    * @param {string} text                                  Caption text
    * @param {object} [opts]
    * @param {number} [opts.fontSize=16]        Font size in px
    * @param {string} [opts.bgColor='#000']     Background hex color (e.g. '#000', '#ff0000')
    * @param {number} [opts.bgOpacity=0.5]      Background alpha (0â€“1)
    * @param {string} [opts.textColor='#fff']   Text color
    * @param {number} [opts.paddingEm=0.5]      Padding around text (in em)
    * @returns {HTMLElement}                     The caption element
    */
    function addTextBelowBox(viewer, box, text, opts = {}) {
      // Default options
      const {
        fontSize = 16,
        bgColor = '#000',
        bgOpacity = 0.5,
        textColor = '#fff',
        paddingEm = 0.5,
      } = opts;

      // Helper: turn '#rgb' or '#rrggbb' into 'rgba(r,g,b,alpha)'
      function hexToRgba(hex, alpha) {
        let h = hex.replace('#', '');
        if (h.length === 3) {
          h = h.split('').map(c => c + c).join('');
        }
        const int = parseInt(h, 16);
        const r = (int >> 16) & 255;
        const g = (int >> 8) & 255;
        const b = int & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      // 1) Create and style the DIV
      const div = document.createElement('div');
      div.textContent = text;
      Object.assign(div.style, {
        width: `${box.w}px`,
        textAlign: 'center',
        position: 'absolute',
        display: 'inline-block',
        fontSize: fontSize + 'px',
        backgroundColor: hexToRgba(bgColor, bgOpacity),
        color: textColor,
        padding: `${paddingEm}em`,
        boxSizing: 'border-box',
        whiteSpace: 'pre-wrap',
        pointerEvents: 'none',
        opacity: '1'            // ensure text remains fully opaque
      });

      // 2) Compute the bottom-center of the box in image coords
      const imgX = box.x + box.w / 2;
      const imgY = box.y + box.h;

      // 3) Convert to viewport coords
      const vp = viewer.viewport.imageToViewportCoordinates(box.x, imgY);

      // 4) Add as a TOP-centered overlay (auto-width)
      viewer.addOverlay({
        element: div,
        location: new OpenSeadragon.Point(vp.x, vp.y),
        placement: OpenSeadragon.Placement.TOP
      });

      return div;
    }

    /**
* Draws a border around an imageâ€pixel box in an OpenSeadragon viewer.
*
* @param {OpenSeadragon.Viewer} viewer
* @param {{x:number,y:number,w:number,h:number}} box
*        Box in imageâ€pixel coords (top-left + width/height).
* @param {object} [opts]
* @param {string} [opts.color='red']     Border color (any CSS color).
* @param {number} [opts.lineWidth=2]     Border thickness in px.
* @returns {HTMLElement}                 The overlay element (for later removal).
*/
    function drawBoxBorder(viewer, box, opts = {}) {
      const {
        color = 'red',
        lineWidth = 2,
      } = opts;

      // 1) make a DIV sized to 100% Ã— 100% of its overlay rectangle,
      //    with only a border and transparent fill
      const div = document.createElement('div');
      Object.assign(div.style, {
        position: 'absolute',
        width: '100%',
        height: '100%',
        boxSizing: 'border-box',
        border: `${lineWidth}px solid ${color}`,
        background: 'transparent',
        pointerEvents: 'none',
      });

      // 2) map the box corners to viewport coords
      const vpTL = viewer.viewport.imageToViewportCoordinates(box.x, box.y);
      const vpTR = viewer.viewport.imageToViewportCoordinates(box.x + box.w, box.y);
      const vpBL = viewer.viewport.imageToViewportCoordinates(box.x, box.y + box.h);

      const widthVP = vpTR.x - vpTL.x;
      const heightVP = vpBL.y - vpTL.y;

      // 3) build the overlay rectangle
      const rect = new OpenSeadragon.Rect(
        vpTL.x,
        vpTL.y,
        widthVP,
        heightVP
      );

      // 4) add it to the viewer
      viewer.addOverlay({
        element: div,
        location: rect
      });

      return div;
    }

    const parseRegionString = (region, center) => {
      const s1 = region.split(':')
      let [x, y, w, h] = s1[s1.length - 1].split(',').map(v => parseInt(v))
      const size = viewer.world.getItemAt(0)?.getContentSize()
      if (!size) return
      if (s1.length === 2 && (s1[0] === 'pct' || s1[0] === 'percent')) {
        x = Math.round(size.x * x / 100),
          y = Math.round(size.y * y / 100),
          w = Math.round(size.x * w / 100),
          h = Math.round(size.y * h / 100)
      }
      return center
        ? ({ x, y, w, h } = expandBox({ x, y, w, h }))
        : ({ x, y, w, h })
    }

    let zoomedToRegion = ''
    const zoomto = (regionStr, caption) => {
      viewer.clearOverlays();
      if (zoomedToRegion === regionStr) {
        viewer.viewport.goHome()
        zoomedToRegion = ''
      } else {
        zoomedToRegion = regionStr
        let region = parseRegionString(regionStr, false)
        let expandedRegion = parseRegionString(regionStr, true)
        setTimeout(() => {
          let rect = viewer.viewport.imageToViewportRectangle(...Object.values(expandedRegion))
          viewer.viewport.fitBounds(rect, false)
          const borderEl = drawBoxBorder(viewer, region, {
            color: '#FFFF00',
            lineWidth: 2
          });
          if (caption) addTextBelowBox(viewer, region, caption, {
            fontSize: '1em',
            bgColor: "#fff",
            bgOpacity: 0.8,
            textColor: "#000",
            paddingEm: 0.3
          });
        }, 100)
      }
    }

    // --- Helpers: IIIF-like rotate/region ---
    function parseRotate(v) {
      if (!v) return { flip: false, degrees: 0 };
      const s = String(v).trim();
      const flip = s.startsWith("!");
      const deg = parseFloat(flip ? s.slice(1) : s);
      return {
        flip,
        degrees: Number.isFinite(deg) ? ((deg % 360) + 360) % 360 : 0
      };
    }

    function parseRegion(v, w, h) {
      if (!v) return null;
      const raw = String(v).trim();
      if (!raw || raw.toLowerCase() === "full") return null;

      let s = raw;
      let pct = false;

      if (s.toLowerCase().startsWith("pct:")) {
        pct = true;
        s = s.slice(4);
      }

      const parts = s.split(",").map(p => parseFloat(p.trim()));
      if (parts.length !== 4 || parts.some(n => !Number.isFinite(n))) return null;

      let [x, y, rw, rh] = parts;

      if (pct) {
        x = (x / 100) * w;
        y = (y / 100) * h;
        rw = (rw / 100) * w;
        rh = (rh / 100) * h;
      }

      // Clamp to image bounds
      x = Math.max(0, Math.min(x, w));
      y = Math.max(0, Math.min(y, h));
      rw = Math.max(0, Math.min(rw, w - x));
      rh = Math.max(0, Math.min(rh, h - y));

      if (rw <= 0 || rh <= 0) return null;

      return new OpenSeadragon.Rect(x, y, rw, rh);
    }

    // --- Cover: crop-based (no letterbox) ---
    function fitCover(viewer, itemBounds) {
      const vp = viewer.viewport;
      const containerSize = vp.getContainerSize(); // pixels
      const vpAspect = containerSize.x / containerSize.y;

      const b = itemBounds.clone(); // viewport coords
      const bAspect = b.width / b.height;

      if (bAspect > vpAspect) {
        // wider than viewport: crop width (zoom in)
        const newW = b.height * vpAspect;
        const dx = (b.width - newW) / 2;
        b.x += dx;
        b.width = newW;
      } else {
        // taller than viewport: crop height (zoom in)
        const newH = b.width / vpAspect;
        const dy = (b.height - newH) / 2;
        b.y += dy;
        b.height = newH;
      }

      vp.fitBounds(b, true);
    }

    // --- Tooltip: aspect ratio of ENTIRE iframe content (#wrap), incl caption row ---
    function gcd(a, b) {
      a = Math.abs(Math.round(a));
      b = Math.abs(Math.round(b));
      while (b) { const t = b; b = a % b; a = t; }
      return a || 1;
    }

    function iframeAspectText(w, h) {
      const g = gcd(w, h);
      const rw = Math.round(w / g);
      const rh = Math.round(h / g);
      const dec = w / h;
      return `Iframe aspect: ${rw}:${rh} (${dec.toFixed(3)})`;
    }

    function updateIframeAspectTip() {
      const wrap = document.getElementById("wrap");
      const tip = document.getElementById("ar-tip");
      if (!wrap || !tip) return;

      const r = wrap.getBoundingClientRect();
      const w = Math.max(1, Math.round(r.width));
      const h = Math.max(1, Math.round(r.height));
      tip.textContent = iframeAspectText(w, h);
    }

    // Caption (Chirpy-like)
    if (captionStr) {
      capEl.textContent = captionStr;
      capEl.style.display = "block";
      updateIframeAspectTip(); // caption affects wrap height
    }

    function attachStaticClickHandler(viewer, onClick) {
      viewer.container.addEventListener(
        "click",
        (e) => {
          // Allow scrolling; click is separate and safe to own here.
          e.preventDefault();
          e.stopImmediatePropagation();
          onClick?.(e);
        },
        true // capture
      );

      // Optional: also block double-click so it doesn't do anything weird
      viewer.container.addEventListener(
        "dblclick",
        (e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
        },
        true
      );
    }

    function enableModifierWheelZoom(viewer) {
      viewer.container.addEventListener(
        "wheel",
        (e) => {
          const zoomIntent = e.ctrlKey || e.metaKey; // Ctrl / âŒ˜
          if (!zoomIntent) return; // let the page scroll

          e.preventDefault();
          e.stopImmediatePropagation();

          const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
          const webPoint = viewer.viewport.pointFromPixel(
            new OpenSeadragon.Point(e.clientX, e.clientY),
            true
          );

          viewer.viewport.zoomBy(factor, webPoint, true);
          viewer.viewport.applyConstraints();
        },
        { passive: false, capture: true }
      );
    }

    const boundingBoxHandler = (e) => {
      const container = document.getElementById("osd");
      const overlay = document.getElementById("drawing-overlay");
      const ctx = overlay.getContext("2d");
      let isDrawing = false, startX = 0, startY = 0;

      // Array of { rect, el, updateOverlay }
      const boxes = [];

      function resizeOverlay() {
        overlay.width = container.clientWidth;
        overlay.height = container.clientHeight;
      }
      window.addEventListener("resize", resizeOverlay);
      resizeOverlay();

      function updateAllBoxes() {
        boxes.forEach(b => b.updateOverlay());
      }

      viewer.addHandler("viewport-change", updateAllBoxes);

      // === NEW BOX DRAWING ===
      container.addEventListener("pointerdown", e => {
        if (!e.shiftKey) return;
        e.preventDefault(); e.stopImmediatePropagation();
        isDrawing = true;
        viewer.setMouseNavEnabled(false);
        overlay.style.pointerEvents = "auto";
        const r = overlay.getBoundingClientRect();
        startX = e.clientX - r.left;
        startY = e.clientY - r.top;
      }, { capture: true });

      document.addEventListener("pointermove", e => {
        if (!isDrawing) return;
        const r = overlay.getBoundingClientRect();
        const x = e.clientX - r.left, y = e.clientY - r.top;
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        ctx.strokeStyle = "red"; ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, x - startX, y - startY);
      });

      document.addEventListener("pointerup", e => {
        if (!isDrawing) return;
        isDrawing = false;
        viewer.setMouseNavEnabled(true);
        overlay.style.pointerEvents = "none";
        ctx.clearRect(0, 0, overlay.width, overlay.height);

        const r = overlay.getBoundingClientRect();
        const endX = e.clientX - r.left, endY = e.clientY - r.top;
        const tl = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(startX, startY));
        const br = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(endX, endY));

        const rect = { x: tl.x, y: tl.y, width: br.x - tl.x, height: br.y - tl.y };

        // Create the HTML overlay
        const boxEl = document.createElement("div");
        boxEl.className = "box";
        container.appendChild(boxEl);

        // Resize handlers
        ['nw', 'ne', 'sw', 'se'].forEach(pos => {
          const h = document.createElement("div");
          h.className = `handle ${pos}`;
          boxEl.appendChild(h);
        });

        // Copy icon
        const icon = document.createElement('div');
        icon.className = 'copy-icon';
        icon.textContent = 'ðŸ“‹';
        boxEl.appendChild(icon);
        icon.addEventListener('click', () => {
          if (document.hasFocus()) {
            navigator.clipboard.writeText('Hello world!').catch(err => console.error('Copy failed:', err));
          } else {
            alert('Please click on the window to focus it before copying.');
          }
          const regionPct = `pct:${(rect.x * 100).toFixed(2)},${(rect.y * 100 * imageAspect).toFixed(2)},${(rect.width * 100).toFixed(2)},${(rect.height * 100 * imageAspect).toFixed(2)}`
          // navigator.clipboard.writeText(`${id}/zoomto/${regionPct}`);
          navigator.clipboard.writeText(regionPct);
        });

        // Define updateOverlay function
        function updateOverlay() {
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x, rect.y), true);
          const brp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x + rect.width, rect.y + rect.height), true);
          const w = brp.x - tlp.x, h = brp.y - tlp.y;
          boxEl.style.left = tlp.x + "px";
          boxEl.style.top = tlp.y + "px";
          boxEl.style.width = w + "px";
          boxEl.style.height = h + "px";
          // position icon
          icon.style.left = (w - 10) + "px";
          icon.style.top = (h - 10) + "px";
        }

        // Initial positioning
        updateOverlay();

        // Add to array
        boxes.push({ rect, el: boxEl, updateOverlay });

        // === MOVE & RESIZE INTERACTIONS ===
        let action = null, handlePos = null, startPx = 0, startPy = 0, origRect;

        boxEl.addEventListener("pointerdown", e => {
          e.stopPropagation(); e.preventDefault();
          if (e.target.classList.contains("handle")) {
            action = "resize";
            handlePos = ['nw', 'ne', 'sw', 'se'].find(p => e.target.classList.contains(p));
          } else {
            action = "move";
          }
          viewer.setMouseNavEnabled(false);
          startPx = e.clientX; startPy = e.clientY;
          origRect = { ...rect };
        });

        document.addEventListener("pointermove", e => {
          if (!action) return;
          const dx = e.clientX - startPx, dy = e.clientY - startPy;
          // get original corners in pixel space
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(origRect.x, origRect.y), true);
          const brp = viewer.viewport.pixelFromPoint(
            new OpenSeadragon.Point(origRect.x + origRect.width, origRect.y + origRect.height), true
          );
          let leftPx = tlp.x, topPx = tlp.y, rightPx = brp.x, bottomPx = brp.y;

          if (action === "move") {
            leftPx += dx; rightPx += dx;
            topPx += dy; bottomPx += dy;
          } else {
            if (handlePos.includes("n")) topPx += dy;
            if (handlePos.includes("s")) bottomPx += dy;
            if (handlePos.includes("w")) leftPx += dx;
            if (handlePos.includes("e")) rightPx += dx;
          }

          // convert back to image coords
          const newTL = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(leftPx, topPx));
          const newBR = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(rightPx, bottomPx));
          rect.x = newTL.x;
          rect.y = newTL.y;
          rect.width = newBR.x - newTL.x;
          rect.height = newBR.y - newTL.y;

          updateOverlay();
        });

        document.addEventListener("pointerup", () => {
          if (!action) return;
          action = null;
          viewer.setMouseNavEnabled(true);
        });
      });

      // Clear on Escape
      document.addEventListener("keydown", e => {
        if (e.key === "Escape") {
          boxes.forEach(b => container.removeChild(b.el));
          boxes.length = 0;
        }
      });
    }

    const viewer = OpenSeadragon({
      id: "osd",
      prefixUrl: "https://cdn.jsdelivr.net/npm/openseadragon@5.0.1/build/openseadragon/images/",

      // Controls only in max mode
      showNavigationControl: max,
      showZoomControl: max,
      showHomeControl: max,
      showFullPageControl: max,
      showRotationControl: max,
      showNavigator: false,
      keyboard: max,

      // The big switch:
      mouseNavEnabled: max,

      // Gestures: make it behave like a static image when not max
      gestureSettingsMouse: {
        scrollToZoom: max,        // wheel zoom only in max
        dragToPan: max,           // pan only in max
        clickToZoom: max,
        dblClickToZoom: max,
        pinchToZoom: max
      },
      gestureSettingsTouch: {
        scrollToZoom: max,
        dragToPan: max,
        clickToZoom: max,
        dblClickToZoom: max,
        pinchToZoom: max
      }
    });

    // In static mode, explicitly allow the browser to scroll normally on touch/trackpads.
    // (Doesn't hurt desktop mouse wheels either.)
    viewer.container.style.touchAction = max ? "none" : "pan-y";

    viewer.addHandler("open", () => {
      const item = viewer.world.getItemAt(0);
      if (!item) return;

      const size = item.getContentSize(); // image pixel dimensions
      const width = size.x;
      const height = size.y;

      imageAspect = width / height;
      boundingBoxHandler()
    });

    viewer.open({ type: "image", url: src });

    viewer.addHandler("open-failed", () => {
      showMsg("Failed to load image. The image host may not allow cross-origin access (CORS).");
    });

    if (!max) {
      attachStaticClickHandler(viewer, () => {
        window.parent.postMessage({ type: 'showDialog', props: { aspect: 1.0, src: `${location.href}&max` } }, '*');
      });

      // Optional:
      enableModifierWheelZoom(viewer);
    }

    viewer.addHandler("open", () => {
      const item = viewer.world.getItemAt(0);
      if (!item) return;

      // Region (IIIF-like)
      const size = item.getContentSize(); // raw image pixel dims
      const clip = parseRegion(regionStr, size.x, size.y);
      if (clip) item.setClip(clip);

      // Rotate (IIIF-like) + optional flip via "!"
      const rot = parseRotate(rotateStr);
      if (rot.flip && typeof item.setFlip === "function") item.setFlip(true);
      viewer.viewport.setRotation(rot.degrees);

      // Initial view
      viewer.viewport.goHome(true);

      // Cover mode (crop-based)
      if (cover) {
        const bounds = item.getBounds(true); // accounts for clip
        fitCover(viewer, bounds);
      }

      // Tooltip (iframe aspect incl caption)
      updateIframeAspectTip();
    });

    // Keep tooltip accurate on resize / layout changes
    window.addEventListener("resize", updateIframeAspectTip);

    if ("ResizeObserver" in window) {
      const ro = new ResizeObserver(updateIframeAspectTip);
      ro.observe(document.getElementById("wrap"));
    } else {
      // Fallback: periodic refresh (rarely needed)
      setInterval(updateIframeAspectTip, 750);
    }

    // Initial tooltip text (even before image opens)
    updateIframeAspectTip();
  </script>
</body>

</html>