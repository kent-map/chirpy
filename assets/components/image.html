<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Viewer</title>

  <!-- OpenSeadragon -->
  <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0.1/build/openseadragon/openseadragon.min.js"></script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      /* background: #111; */
    }

    /* Wrap includes BOTH viewer + caption area */
    #wrap {
      height: 100%;
      display: grid;
      grid-template-rows: 1fr auto;
      position: relative;
      /* for bottom-right hotspot */
    }

    #osd {
      width: 100%;
      height: 100%;
      background: #111;
    }

    /* Chirpy-like caption (muted, centered, no banner) */
    #caption {
      display: none;
      text-align: center;
      font-size: 0.8em;
      line-height: 1.4;
      margin-top: 0.25rem;
      padding: 0;
      color: #6d6c6c;
      background: transparent;
      word-break: break-word;
    }

    @media (prefers-color-scheme: dark) {
      #caption {
        color: rgba(255, 255, 255, 0.55);
      }
    }

    /* Error banner */
    #msg {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px 12px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #fff;
      background: rgba(180, 40, 40, 0.9);
      display: none;
      z-index: 1000;
    }

    code {
      background: rgba(255, 255, 255, .1);
      padding: 0 4px;
      border-radius: 4px;
    }

    /* Bottom-right hover hotspot + tooltip */
    #ar-hotspot {
      position: absolute;
      right: 10px;
      bottom: 10px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .10);
      border: 1px solid rgba(255, 255, 255, .18);
      z-index: 50;
      pointer-events: auto;
    }

    #ar-tip {
      position: absolute;
      right: 0;
      bottom: 26px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(0, 0, 0, .80);
      color: rgba(255, 255, 255, .90);
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      white-space: nowrap;
      transform: translateY(4px);
      opacity: 0;
      transition: opacity 120ms ease, transform 120ms ease;
      pointer-events: none;
    }

    #ar-hotspot:hover #ar-tip {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div id="msg"></div>

  <div id="wrap">
    <div id="osd"></div>

    <!-- bottom-right hover hotspot + tooltip (aspect ratio of entire iframe, incl caption) -->
    <div id="ar-hotspot" aria-label="Iframe aspect ratio">
      <div id="ar-tip"></div>
    </div>

    <div id="caption"></div>
  </div>

  <script>
    const params = new URLSearchParams(location.search);

    const src = params.get("src");
    const captionStr = params.get("caption");
    const cover = params.get("cover") === "1"; // viewer expects cover=1
    const regionStr = params.get("region");        // "full" | "x,y,w,h" | "pct:x,y,w,h"
    const rotateStr = params.get("rotate");        // "0" | "90" | "!90" etc

    const msgEl = document.getElementById("msg");
    const capEl = document.getElementById("caption");

    function showMsg(html) {
      msgEl.innerHTML = html;
      msgEl.style.display = "block";
    }

    if (!src) {
      showMsg(`Missing <code>?src=</code> parameter.`);
      throw new Error("Missing src");
    }

    window.addEventListener('message', (event) => {
      if (!event.data) return;
      let eventData = JSON.parse(event.data)
      let action = eventData.action?.toLowerCase()
      let text = eventData.text
      let args = eventData.args
      console.log(action, args);
      if (action === 'zoomto') {
        zoomto(args[0], text)
      }
    });

    /**
    * Expand a bounding box to twice its width and height,
    * centering the original box inside the new one.
    *
    * @param {{x:number, y:number, w:number, h:number}} box
    *   The original bounding box.
    * @param {'round'|'floor'|'ceil'} [rounding='round']
    *   How to round the computed coordinates.
    * @returns {{x:number, y:number, w:number, h:number}}
    *   The expanded, centered bounding box.
    */
    function expandBox(box, rounding = 'round') {
      let scale = 1.8;
      // New dimensions
      const newW = box.w * scale;
      const newH = box.h * scale;

      // Center of the original box
      const cx = box.x + box.w / scale;
      const cy = box.y + box.h / scale;

      // Compute top-left of the expanded box so it's centered on (cx,cy)
      let x = cx - newW / scale;
      let y = cy - newH / scale;

      // Apply rounding
      if (rounding === 'floor') {
        x = Math.floor(x);
        y = Math.floor(y);
      } else if (rounding === 'ceil') {
        x = Math.ceil(x);
        y = Math.ceil(y);
      } else {
        x = Math.round(x);
        y = Math.round(y);
      }

      return { x, y, w: newW, h: newH };
    }

    /**
    * Place a padded, semi‐transparent text caption under a box,
    * with fully opaque text.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box   Image‐pixel bbox
    * @param {string} text                                  Caption text
    * @param {object} [opts]
    * @param {number} [opts.fontSize=16]        Font size in px
    * @param {string} [opts.bgColor='#000']     Background hex color (e.g. '#000', '#ff0000')
    * @param {number} [opts.bgOpacity=0.5]      Background alpha (0–1)
    * @param {string} [opts.textColor='#fff']   Text color
    * @param {number} [opts.paddingEm=0.5]      Padding around text (in em)
    * @returns {HTMLElement}                     The caption element
    */
    function addTextBelowBox(viewer, box, text, opts = {}) {
      // Default options
      const {
        fontSize = 16,
        bgColor = '#000',
        bgOpacity = 0.5,
        textColor = '#fff',
        paddingEm = 0.5,
      } = opts;

      // Helper: turn '#rgb' or '#rrggbb' into 'rgba(r,g,b,alpha)'
      function hexToRgba(hex, alpha) {
        let h = hex.replace('#', '');
        if (h.length === 3) {
          h = h.split('').map(c => c + c).join('');
        }
        const int = parseInt(h, 16);
        const r = (int >> 16) & 255;
        const g = (int >> 8) & 255;
        const b = int & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      // 1) Create and style the DIV
      const div = document.createElement('div');
      div.textContent = text;
      Object.assign(div.style, {
        width: `${box.w}px`,
        textAlign: 'center',
        position: 'absolute',
        display: 'inline-block',
        fontSize: fontSize + 'px',
        backgroundColor: hexToRgba(bgColor, bgOpacity),
        color: textColor,
        padding: `${paddingEm}em`,
        boxSizing: 'border-box',
        whiteSpace: 'pre-wrap',
        pointerEvents: 'none',
        opacity: '1'            // ensure text remains fully opaque
      });

      // 2) Compute the bottom-center of the box in image coords
      const imgX = box.x + box.w / 2;
      const imgY = box.y + box.h;

      // 3) Convert to viewport coords
      const vp = viewer.viewport.imageToViewportCoordinates(box.x, imgY);

      // 4) Add as a TOP-centered overlay (auto-width)
      viewer.addOverlay({
        element: div,
        location: new OpenSeadragon.Point(vp.x, vp.y),
        placement: OpenSeadragon.Placement.TOP
      });

      return div;
    }

    /**
* Draws a border around an image‐pixel box in an OpenSeadragon viewer.
*
* @param {OpenSeadragon.Viewer} viewer
* @param {{x:number,y:number,w:number,h:number}} box
*        Box in image‐pixel coords (top-left + width/height).
* @param {object} [opts]
* @param {string} [opts.color='red']     Border color (any CSS color).
* @param {number} [opts.lineWidth=2]     Border thickness in px.
* @returns {HTMLElement}                 The overlay element (for later removal).
*/
    function drawBoxBorder(viewer, box, opts = {}) {
      const {
        color = 'red',
        lineWidth = 2,
      } = opts;

      // 1) make a DIV sized to 100% × 100% of its overlay rectangle,
      //    with only a border and transparent fill
      const div = document.createElement('div');
      Object.assign(div.style, {
        position: 'absolute',
        width: '100%',
        height: '100%',
        boxSizing: 'border-box',
        border: `${lineWidth}px solid ${color}`,
        background: 'transparent',
        pointerEvents: 'none',
      });

      // 2) map the box corners to viewport coords
      const vpTL = viewer.viewport.imageToViewportCoordinates(box.x, box.y);
      const vpTR = viewer.viewport.imageToViewportCoordinates(box.x + box.w, box.y);
      const vpBL = viewer.viewport.imageToViewportCoordinates(box.x, box.y + box.h);

      const widthVP = vpTR.x - vpTL.x;
      const heightVP = vpBL.y - vpTL.y;

      // 3) build the overlay rectangle
      const rect = new OpenSeadragon.Rect(
        vpTL.x,
        vpTL.y,
        widthVP,
        heightVP
      );

      // 4) add it to the viewer
      viewer.addOverlay({
        element: div,
        location: rect
      });

      return div;
    }

    const parseRegionString = (region, center) => {
      const s1 = region.split(':')
      let [x, y, w, h] = s1[s1.length - 1].split(',').map(v => parseInt(v))
      const size = viewer.world.getItemAt(0)?.getContentSize()
      if (!size) return
      if (s1.length === 2 && (s1[0] === 'pct' || s1[0] === 'percent')) {
        x = Math.round(size.x * x / 100),
          y = Math.round(size.y * y / 100),
          w = Math.round(size.x * w / 100),
          h = Math.round(size.y * h / 100)
      }
      return center
        ? ({ x, y, w, h } = expandBox({ x, y, w, h }))
        : ({ x, y, w, h })
    }

    let zoomedToRegion = ''
    const zoomto = (regionStr, caption) => {
      viewer.clearOverlays();
      if (zoomedToRegion === regionStr) {
        viewer.viewport.goHome()
        zoomedToRegion = ''
      } else {
        zoomedToRegion = regionStr
        let region = parseRegionString(regionStr, false)
        let expandedRegion = parseRegionString(regionStr, true)
        setTimeout(() => {
          let rect = viewer.viewport.imageToViewportRectangle(...Object.values(expandedRegion))
          viewer.viewport.fitBounds(rect, false)
          const borderEl = drawBoxBorder(viewer, region, {
            color: '#FFFF00',
            lineWidth: 2
          });
          if (caption) addTextBelowBox(viewer, region, caption, {
            fontSize: '1em',
            bgColor: "#fff",
            bgOpacity: 0.8,
            textColor: "#000",
            paddingEm: 0.3
          });
        }, 100)
      }
    }

    // --- Helpers: IIIF-like rotate/region ---
    function parseRotate(v) {
      if (!v) return { flip: false, degrees: 0 };
      const s = String(v).trim();
      const flip = s.startsWith("!");
      const deg = parseFloat(flip ? s.slice(1) : s);
      return {
        flip,
        degrees: Number.isFinite(deg) ? ((deg % 360) + 360) % 360 : 0
      };
    }

    function parseRegion(v, w, h) {
      if (!v) return null;
      const raw = String(v).trim();
      if (!raw || raw.toLowerCase() === "full") return null;

      let s = raw;
      let pct = false;

      if (s.toLowerCase().startsWith("pct:")) {
        pct = true;
        s = s.slice(4);
      }

      const parts = s.split(",").map(p => parseFloat(p.trim()));
      if (parts.length !== 4 || parts.some(n => !Number.isFinite(n))) return null;

      let [x, y, rw, rh] = parts;

      if (pct) {
        x = (x / 100) * w;
        y = (y / 100) * h;
        rw = (rw / 100) * w;
        rh = (rh / 100) * h;
      }

      // Clamp to image bounds
      x = Math.max(0, Math.min(x, w));
      y = Math.max(0, Math.min(y, h));
      rw = Math.max(0, Math.min(rw, w - x));
      rh = Math.max(0, Math.min(rh, h - y));

      if (rw <= 0 || rh <= 0) return null;

      return new OpenSeadragon.Rect(x, y, rw, rh);
    }

    // --- Cover: crop-based (no letterbox) ---
    function fitCover(viewer, itemBounds) {
      const vp = viewer.viewport;
      const containerSize = vp.getContainerSize(); // pixels
      const vpAspect = containerSize.x / containerSize.y;

      const b = itemBounds.clone(); // viewport coords
      const bAspect = b.width / b.height;

      if (bAspect > vpAspect) {
        // wider than viewport: crop width (zoom in)
        const newW = b.height * vpAspect;
        const dx = (b.width - newW) / 2;
        b.x += dx;
        b.width = newW;
      } else {
        // taller than viewport: crop height (zoom in)
        const newH = b.width / vpAspect;
        const dy = (b.height - newH) / 2;
        b.y += dy;
        b.height = newH;
      }

      vp.fitBounds(b, true);
    }

    // --- Tooltip: aspect ratio of ENTIRE iframe content (#wrap), incl caption row ---
    function gcd(a, b) {
      a = Math.abs(Math.round(a));
      b = Math.abs(Math.round(b));
      while (b) { const t = b; b = a % b; a = t; }
      return a || 1;
    }

    function iframeAspectText(w, h) {
      const g = gcd(w, h);
      const rw = Math.round(w / g);
      const rh = Math.round(h / g);
      const dec = w / h;
      return `Iframe aspect: ${rw}:${rh} (${dec.toFixed(3)})`;
    }

    function updateIframeAspectTip() {
      const wrap = document.getElementById("wrap");
      const tip = document.getElementById("ar-tip");
      if (!wrap || !tip) return;

      const r = wrap.getBoundingClientRect();
      const w = Math.max(1, Math.round(r.width));
      const h = Math.max(1, Math.round(r.height));
      tip.textContent = iframeAspectText(w, h);
    }

    // Caption (Chirpy-like)
    if (captionStr) {
      capEl.textContent = captionStr;
      capEl.style.display = "block";
      updateIframeAspectTip(); // caption affects wrap height
    }

    // Set up viewer
    const viewer = OpenSeadragon({
      id: "osd",
      prefixUrl: "https://cdn.jsdelivr.net/npm/openseadragon@5.0.1/build/openseadragon/images/",
      showNavigator: true,
      showRotationControl: true,
      gestureSettingsMouse: { scrollToZoom: true }
    });

    viewer.open({ type: "image", url: src });

    viewer.addHandler("open-failed", () => {
      showMsg("Failed to load image. The image host may not allow cross-origin access (CORS).");
    });

    viewer.addHandler("open", () => {
      const item = viewer.world.getItemAt(0);
      if (!item) return;

      // Region (IIIF-like)
      const size = item.getContentSize(); // raw image pixel dims
      const clip = parseRegion(regionStr, size.x, size.y);
      if (clip) item.setClip(clip);

      // Rotate (IIIF-like) + optional flip via "!"
      const rot = parseRotate(rotateStr);
      if (rot.flip && typeof item.setFlip === "function") item.setFlip(true);
      viewer.viewport.setRotation(rot.degrees);

      // Initial view
      viewer.viewport.goHome(true);

      // Cover mode (crop-based)
      if (cover) {
        const bounds = item.getBounds(true); // accounts for clip
        fitCover(viewer, bounds);
      }

      // Tooltip (iframe aspect incl caption)
      updateIframeAspectTip();
    });

    // Keep tooltip accurate on resize / layout changes
    window.addEventListener("resize", updateIframeAspectTip);

    if ("ResizeObserver" in window) {
      const ro = new ResizeObserver(updateIframeAspectTip);
      ro.observe(document.getElementById("wrap"));
    } else {
      // Fallback: periodic refresh (rarely needed)
      setInterval(updateIframeAspectTip, 750);
    }

    // Initial tooltip text (even before image opens)
    updateIframeAspectTip();
  </script>
</body>

</html>