<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Component</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="//unpkg.com/leaflet-gesture-handling/dist/leaflet-gesture-handling.min.css" />
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&amp;family=Source+Sans+Pro:wght@400;600;700;900&amp;display=swap" />
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    @keyframes fadeInOpacity {
      0% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* ------------------------------------------------------------------
      Global reset so the iframe box behaves predictably
    ------------------------------------------------------------------ */
    html,
    body {
      margin: 0;
      height: 100%;
      /* let the flexbox fill the iframe */
      box-sizing: border-box;
      font-family: system-ui, sans-serif;
    }

    main {
      height: 100%;
      display: flex;
      flex-direction: column;
      width: 100%;
      visibility: hidden;
    }

    /* ------------------------------------------------------------------
      Layout: figure stretches to full iframe height, image flexes,
      caption is a fixed-height band (16 px text, 8 px padding each side)
    ------------------------------------------------------------------ */
    figure {
      height: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    figure {
      display: grid;
      grid-template-rows: 1fr auto;
      height: 100%;
      margin: 0;
    }

    #content {
      position: relative;
      flex: 1;
      width: 100%;
      z-index: 2;
    }

    figure #map {
      width: 100%;
      height: 100%;
      /* keeps natural aspect */
      flex: 1 0 0;
      /* consume whatever height is left */
    }

    /* ---- caption ------------------------------------------------------- */
    figcaption {
      font-family: "Source Sans Pro", "Helvetica Neue", Arial, sans-serif;
      font-size: 16px;
      line-height: 28px;
      padding: 8px 0;
      /* 8 px top + bottom (fixed) */
      text-align: left;
      /* left-align text */
      display: flex;
      align-items: center;
      background: #fff;
      color: rgb(52, 52, 60);
      font-style: italic;
      font-weight: 400;
      -webkit-font-smoothing: antialiased;
    }


    /* ---- any inline SVG icons in the caption --------------------------- */
    figcaption svg {
      width: 1em;
      /* 1 × font-size → scales with 16 px text */
      height: 1em;
      margin-inline: .3em;
      flex: none;
      /* don’t let flexbox shrink it */
      fill: currentColor;
      /* inherit text colour automatically */
    }

    /*
    body { height:100dvh; margin: 0; padding: 0; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; animation: fadeInOpacity ease 1s; background-color: white; }    
    main { height: 100%; display: flex; flex-direction: column; width: 100%; visibility: hidden; } 
    figure { display: grid; grid-template-rows: 1fr auto; height: 100%; margin: 0; }
    #content { position:relative; flex: 1; width: 100%; z-index: 2;}
    figcaption { display: inline-flex; align-items: center; gap: 0.4em; line-height: 1.2; }
    figcaption svg { width: 1em; height: 1em; flex: none; fill: currentColor; cursor: pointer; }
    #map { width:100%; height:100%; cursor:pointer; }
    */

    sl-tab::part(base) {
      padding: 0.5em 1em;
    }

    sl-tab-panel::part(base) {
      padding: 0.5em;
    }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .wrap {
      overflow-wrap: break-word;
      word-wrap: break-word;
      -ms-word-break: break-all;
      word-break: break-all;
      word-break: break-word;
    }

    .clamp {
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    h4 {
      margin: 0 0 0.5em 0;
    }

    #coords {
      font-size: .8em;
      opacity: 0;
      position: absolute;
      top: 0;
      right: 0;
      background-color: rgba(255, 255, 255, 0.5);
      border: 1px solid #ccc;
      padding: 0.5em;
      z-index: 500;
      transition: all 0.5s ease-out;
    }

    #coords:hover {
      opacity: 1;
      transition: all 0.3s ease-in;
      cursor: copy;
    }

    .leaflet-popup-content {
      margin: 0;
    }

    .leaflet-control-attribution {
      display: none;
    }

    .leaflet-control-container {
      opacity: 0;
      transition: all 0.3s ease-in;
    }

    .leaflet-container:hover .leaflet-control-container {
      opacity: 1;
    }

    :root {
      --popup-card-width: 300px;
      /* change once, affects all cards */
      --popup-gap: 10px;
      --popup-pad: 10px;
      --thumb-ratio: 1 / 1;
      /* square thumbnail */
    }

    /* Card container */
    .popup-card {
      width: var(--popup-card-width);
      box-sizing: border-box;
      display: grid;
      grid-template-columns: 1fr;
      /* no thumbnail => full width */
      gap: var(--popup-gap);
      padding: var(--popup-pad);
      border-radius: 10px;
    }

    /* Two-column layout when thumbnail exists */
    .popup-card.has-thumb {
      grid-template-columns: 2fr 1fr;
      /* 2/3 text, 1/3 thumbnail */
      align-items: start;
    }

    /* Text column */
    .popup-text {
      display: grid;
      grid-auto-rows: min-content;
      row-gap: 6px;
      min-width: 0;
      /* allow wrapping */
    }

    .popup-label {
      font-weight: 700;
      line-height: 1.2;
    }

    .popup-desc {
      line-height: 1.25;
    }

    /* Thumbnail as background image */
    .popup-thumb {
      width: 100%;
      aspect-ratio: var(--thumb-ratio);
      background-size: cover;
      background-position: center;
      border-radius: 8px;
    }
  </style>
</head>

<body>

  <main>

    <figure>
      <div id="content">
        <div id="coords">Coords</div>
        <div id="map"></div>
      </div>

      <figcaption>
        <div class="title clamp"></div>
      </figcaption>

    </figure>

  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://juncture-digital.github.io/Leaflet.SmoothWheelZoom/Leaflet.SmoothWheelZoom.js"></script>
  <script src="//unpkg.com/leaflet-gesture-handling"></script>
  <script src="https://cdn.jsdelivr.net/npm/@allmaps/leaflet/dist/bundled/allmaps-leaflet-1.9.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
  <script type="module">

    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    import 'https://cdn.jsdelivr.net/npm/js-md5@0.8.3/src/md5.min.js'

    import './leaflet-opacity.js'
    import './turf.min.js'

    // import any needed Shoelace components (https://shoelace.style/)
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/button/button.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab/tab.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-group/tab-group.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-panel/tab-panel.js';

    let imageServiceUrl = 'https://d1co2zgwaj21sl.cloudfront.net/image';

    const baseMapsConfigs = {
      CartoDB_DarkMatter: ['https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_DarkMatterNoLabels: ['https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_DarkMatterOnlyLabels: ['https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_Positron: ['https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_PositronNoLabels: ['https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_PositronOnlyLabels: ['https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_Voyager: ['https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_VoyagerNoLabels: ['https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_VoyagerOnlyLabels: ['https://{s}.basemaps.cartocdn.com/rastertiles/voyager_only_labels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      CartoDB_VoyagerLabelsUnder: ['https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }],
      Esri_DeLorme: ['https://server.arcgisonline.com/ArcGIS/rest/services/Specialty/DeLorme_World_Base_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Copyright: &copy;2012 DeLorme',
        minZoom: 1,
        maxZoom: 11
      }],
      Esri_NatGeoWorldMap: ['https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC',
        maxZoom: 16
      }],
      Esri_OceanBasemap: ['https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri',
        maxZoom: 13
      }],
      Esri_WorldGrayCanvas: ['https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
        maxZoom: 16
      }],
      Esri_WorldImagery: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
      }],
      Esri_WorldPhysical: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 8,
        attribution: 'Tiles &copy; Esri &mdash; Source: US National Park Service'
      }],
      Esri_WorldShadedRelief: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri',
        maxZoom: 13
      }],
      Esri_WorldStreetMap: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
      }],
      Esri_WorldTerrain: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: USGS, Esri, TANA, DeLorme, and NPS',
        maxZoom: 13
      }],
      Esri_WorldTopoMap: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
      }],
      MtbMap: ['http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &amp; USGS'
      }],
      OpenStreetMap: ['https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }],
      OpenStreetMap_DE: ['https://{s}.tile.openstreetmap.de/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }],
      OpenStreetMap_France: ['https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
        maxZoom: 20,
        attribution: '&copy; OpenStreetMap France | &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }],
      OpenStreetMap_HOT: ['https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>',
        maxZoom: 19
      }],
      OpenStreetMap_Mapnik: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
      }],
      OpenTopoMap: ['https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      }],
      OPNVKarte: ['https://tileserver.memomaps.de/tilegen/{z}/{x}/{y}.png', {
        attribution: 'Map <a href="https://memomaps.de/">memomaps.de</a> <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 18
      }],
      Stadia_AlidadeSmooth: ['https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 20
      }],
      Stadia_AlidadeSmoothDark: ['https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 20
      }],
      Stadia_OSMBright: ['https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 20
      }],
      Stadia_Outdoors: ['https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.png', {
        maxZoom: 20,
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
      }],
      Stamen_Terrain: ['https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 18,
        ext: 'png'
      }],
      Stamen_TerrainBackground: ['https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 18,
        ext: 'png'
      }],
      Stamen_TerrainLabels: ['https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-labels/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 18,
        ext: 'png'
      }],
      Stamen_Toner: ['https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 20,
        ext: 'png'
      }],
      Stamen_TonerBackground: ['https://stamen-tiles-{s}.a.ssl.fastly.net/toner-background/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 20,
        ext: 'png'
      }],
      Stamen_TonerLite: ['https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 20,
        ext: 'png'
      }],
      Stamen_Watercolor: ['https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.{ext}', {
        subdomains: 'abcd',
        minZoom: 1,
        maxZoom: 16,
        ext: 'jpg',
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }],
      USGS_USTopo: ['https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 20,
        attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
      }],
      USGS_USImagery: ['https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 20,
        attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
      }],
      USGS_USImageryTopo: ['https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 20,
        attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
      }],
    }

    const main = document.querySelector('main')
    const figure = main.querySelector('figure')
    const content = document.querySelector('#content')
    const figcaption = figure.querySelector('figcaption')

    const coords = document.querySelector('#coords')
    const mapEl = document.querySelector('#map')

    let map
    let latLngZoom
    let zoomed
    let priorLoc
    let windowAspectRatio = 0.919

    const isMobile = ('ontouchstart' in document.documentElement && /mobi/i.test(navigator.userAgent))

    const getLatLngZoom = (e) => {
      let point = e.type === 'click' ? e.latlng : e.target.getCenter()
      let zoom = e.target.getZoom()
      let _latLngZoom = [point.lat, point.lng, zoom]
      latLngZoom = `${Number((point.lat).toFixed(3))},${Number((point.lng).toFixed(3))},${zoom}`
    }
    const copyTextToClipboard = (text) => navigator.clipboard?.writeText(text)
    coords.addEventListener('click', e => copyTextToClipboard(coords.textContent))

    const coerce = (value) => {
      return (value === 'true' || value === '') ? true
        : (value === 'false') ? false
          : value;
    };

    const params = new URLSearchParams(location.search);

    // --- marker: always string[]
    const marker = params.getAll('marker').filter(v => v !== '');

    // --- everything else
    const queryObj = {};
    for (const key of new Set(params.keys())) {
      if (key === 'marker') continue;

      const values = params.getAll(key).map(coerce);
      queryObj[key] = values.length > 1 ? values : values[0];
    }

    const props = {
      ...{              // defaults
        basemap: 'OpenStreetMap',
        caption: null,
        center: '51.505,-0.09',
        gestureHandling: true,
        ghbase: null,
        markers: '',
        popupOnHover: false,
        'prefer-geojson': false,
        zoom: 8
      },
      ...queryObj,
      marker               // ← normalized override
    };

    console.log(props);

    let inIframe = window.location !== window.parent.location // flag indicating if the page is in an iframe
    const md2Html = (md) => marked.parse(md).slice(3, -5) // convert markdown to HTML
    const capitalizeFirst = (s) => typeof s === 'string' && s.length ? s[0].toUpperCase() + s.slice(1) : s ?? '';
    const setCaption = (caption) => figcaption.innerHTML = md2Html(caption)
    const docReady = (fn) => { if (document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(fn, 1); else document.addEventListener('DOMContentLoaded', fn) }

    let center
    let zoom = 8
    let caption

    const isQid = (s) => /^Q\d+$/.test(s)
    const parseLayerStr = (s) => {
      let tokens = []
      s.replace(/&/g, ' ').replace(/”/g, '"').replace(/”/g, '"').replace(/’/g, "'").match(/[^\s"]+|"([^"]*)"/gmi)?.filter(t => t).forEach(token => {
        if (tokens.length > 0 && tokens[tokens.length - 1].indexOf('=') === tokens[tokens.length - 1].length - 1) tokens[tokens.length - 1] = `${tokens[tokens.length - 1]}${token}`
        else tokens.push(token)
      })
      let parsed = { type: null, kwargs: {}, booleans: [] }
      let tokenIdx = 0
      while (tokenIdx < tokens.length) {
        let token = tokens[tokenIdx].trim()
        if (['marker', 'warped-map', 'geojson'].includes(token)) parsed.type = token
        else if (token.indexOf('=') > 0 && /^[\w-:]+=/.test(token)) {
          let idx = token.indexOf('=')
          let key = token.slice(0, idx)
          let value = token.slice(idx + 1)
          value = value[0] === '"' && value[value.length - 1] === '"' ? value.slice(1, -1) : value
          if (parsed.kwargs[key]) parsed.kwargs[key] += `|${value}`
          else parsed.kwargs[key] = value
        }
        else parsed.booleans.push(token)
        tokenIdx++
      }
      return parsed
    }

    const mwImage = (mwImg, width) => {
      width = width | 0
      // Converts Wikimedia commons image URL to a thumbnail link
      mwImg = (Array.isArray(mwImg) ? mwImg[0] : mwImg).replace(/Special:FilePath\//, 'File:').split('File:').pop()
      mwImg = decodeURIComponent(mwImg).replace(/ /g, '_')
      const _md5 = md5(mwImg)
      const extension = mwImg.split('.').pop()
      let url = `https://upload.wikimedia.org/wikipedia/commons${width ? '/thumb' : ''}`
      url += `/${_md5.slice(0, 1)}/${_md5.slice(0, 2)}/${mwImg}`
      if (width > 0) {
        url += `/${width}px-${mwImg}`
        if (extension === 'svg') {
          url += '.png'
        } else if (extension === 'tif' || extension === 'tiff') {
          url += '.jpg'
        }
      }
      return url
    }

    const fullUrl = (url) => {
      // Converts a URL to a full URL if it is relative or uses a shortcode
      if (url.indexOf('wc:') === 0 || url.indexOf('wikimedia.org') > -1 || url.indexOf('wikipedia.org') > -1 && url.indexOf('/media/File:') > -1) {
        return mwImage(url.replace('wc:', ''), 300)
      } else if (url.indexOf('http') === 0)
        return url
      else if (url.indexOf('gh:') === 0)
        return `https://raw.githubusercontent.com/${url.slice(3)}/main`
      else if (url[0] === '/') {
        let [owner, repo, branch, ...rest] = props.ghbase.split('/')
        return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${url.slice(1)}`
      } else
        return `https://raw.githubusercontent.com/${props.ghbase}/${url}`
    }

    let layerDefs = props.markers.split('::').map(marker => {
      let args = marker.split('|')
      if (isQid(args[0])) {
        return { type: 'marker', qid: args[0], layer: args[1] }
      } else {
        let [coords, label, description, thumbnail, layer] = marker.split('|')
        return {
          type: 'marker',
          coords,
          label: capitalizeFirst(decodeURIComponent(label.replace(/_/g, ' '))),
          description: capitalizeFirst(decodeURIComponent(description.replace(/_/g, ' '))),
          thumbnail: fullUrl(thumbnail),
          layer
        }
      }
    })
    const collectQIDs = () => {
      let qids = new Set()
      if (isQid(props.center)) qids.add(props.center)
      props.markers.split('::').forEach(marker => {
        let args = marker.split('|')
        if (isQid(args[0])) qids.add(args[0])
      })
      return qids
    }

    const makeLocationCard = (locProps) => {
      let card = document.createElement('div')
      card.className = 'popup-card' + (locProps.thumbnail ? ' has-thumb' : '')
      let textWrapper = document.createElement('div')
      textWrapper.className = 'popup-text'
      card.appendChild(textWrapper)
      let label = document.createElement('div')
      label.className = 'popup-label'
      label.textContent = locProps.label
      textWrapper.appendChild(label)
      if (locProps.description) {
        let description = document.createElement('div')
        description.className = 'popup-desc'
        description.innerHTML = locProps.description
        textWrapper.appendChild(description)
      }
      if (locProps.thumbnail) {
        let imgDiv = document.createElement('div')
        imgDiv.className = 'popup-thumb'
        imgDiv.setAttribute('role', 'img')
        imgDiv.setAttribute('aria-label', locProps.label)
        imgDiv.setAttribute('style', `background-image: url('${locProps.thumbnail}');`)
        card.appendChild(imgDiv)
      }
      return card
    }

    const kebabToCamel = (input) => input.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase() })

    const getExifLocationFromUrl = async (imageUrl) => {
      try {
        const response = await fetch(imageUrl, { mode: 'cors' });
        const blob = await response.blob();

        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = function () {
            EXIF.getData(img, function () {
              const lat = EXIF.getTag(this, "GPSLatitude");
              const lon = EXIF.getTag(this, "GPSLongitude");
              const latRef = EXIF.getTag(this, "GPSLatitudeRef") || "N";
              const lonRef = EXIF.getTag(this, "GPSLongitudeRef") || "E";

              if (!lat || !lon) {
                return resolve(null); // No GPS data
              }

              const toDecimal = (dms, ref) => {
                const [deg, min, sec] = dms;
                let dec = deg + min / 60 + sec / 3600;
                if (ref === "S" || ref === "W") dec = -dec;
                return dec;
              };

              const latDec = toDecimal(lat, latRef);
              const lonDec = toDecimal(lon, lonRef);

              resolve(`${latDec},${lonDec}`);
            });
          };
          img.onerror = () => reject(new Error("Failed to load image"));
          img.src = URL.createObjectURL(blob);
        });
      } catch (err) {
        console.error("Error reading EXIF:", err);
        return null;
      }
    }

    // Creates a GeoJSON file URL from a Who's on First ID 
    const whosOnFirstUrl = (wof) => {
      let wofParts = []
      for (let i = 0; i < wof.length; i += 3) {
        wofParts.push(wof.slice(i, i + 3))
      }
      return `https://data.whosonfirst.org/${wofParts.join('/')}/${wof}.geojson`
    }

    const getEntityData = async (qids, language) => {
      language = language || 'en'
      let entities = {}
      let summaryUrls = {}
      let entityUrls = qids.map(qid => `(wd:${qid})`)
      let query = `
      SELECT ?item (SAMPLE(?label) AS ?label) (SAMPLE(?description) AS ?description) (GROUP_CONCAT(?alias; separator=" | ") AS ?aliases) 
          (SAMPLE(?image) AS ?image) (SAMPLE(?logoImage) AS ?logoImage) 
          (SAMPLE(?coords) AS ?coords) (SAMPLE(?pageBanner) AS ?pageBanner)
          (SAMPLE(?whosOnFirst) AS ?whosOnFirst) (SAMPLE(?wikipedia) AS ?wikipedia)
      WHERE {
        VALUES (?item) { ${entityUrls.join(' ')} }

        # BIND(NOW() AS ?timestamp)  # Forces fresh evaluation

        ?item rdfs:label ?label . FILTER (LANG(?label) = "en")
        OPTIONAL { ?item schema:description ?description . FILTER (LANG(?description) = "en") }
        OPTIONAL { ?item skos:altLabel ?alias . FILTER (LANG(?alias) = "en") }
        OPTIONAL { ?item wdt:P625 ?coords . }
        OPTIONAL { ?item wdt:P18 ?image . }
        OPTIONAL { ?item wdt:P154 ?logoImage . }
        OPTIONAL { ?item wdt:P948 ?pageBanner . }
        OPTIONAL { ?item wdt:P6766 ?whosOnFirst . }
        OPTIONAL { ?wikipedia schema:about ?item; schema:isPartOf <https://en.wikipedia.org/> . }
      }
      GROUP BY ?item
      `
      let resp = await fetch('https://query.wikidata.org/sparql', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          Accept: 'application/sparql-results+json'
        },
        body: `query=${encodeURIComponent(query)}`
      })
      if (resp.ok) {
        let sparqlResp = await resp.json()
        sparqlResp.results.bindings.forEach(rec => {
          let qid = rec.item.value.split('/').pop()
          let _entityData = { id: qid, label: rec.label.value }
          if (rec.description) _entityData.description = capitalizeFirst(decodeURIComponent(rec.description.value.replace(/_/g, ' ')))
          if (rec.alias) _entityData.aliases = [rec.alias.value]
          if (rec.coords) _entityData.coords = rec.coords.value.slice(6, -1).split(' ').reverse().join(',')
          if (rec.wikipedia) _entityData.wikipedia = rec.wikipedia.value
          if (rec.pageBanner) _entityData.pageBanner = rec.pageBanner.value
          if (rec.image) {
            _entityData.image = rec.image.value
            _entityData.thumbnail = mwImage(rec.image.value, 300)
          }
          if (rec.logoImage) {
            _entityData.logoImage = rec.logoImage.value
            if (!_entityData.thumbnail) _entityData.thumbnail = mwImage(rec.logoImage.value, 300)
          }
          if (rec.whosOnFirst) _entityData.geojson = whosOnFirstUrl(rec.whosOnFirst.value)

          if (_entityData.wikipedia) {
            let page = _entityData.wikipedia.replace(/\/w\//, '/wiki').split('/wiki/').pop()
            summaryUrls[`https://${language}.wikipedia.org/api/rest_v1/page/summary/${page}`] = qid
          }
          entities[qid] = _entityData
        })
        await Promise.all(Object.keys(summaryUrls).map(url => fetch(url)))
          .then(responses => { return Promise.all(responses.map(resp => resp.json())) })
          .then(data => {
            data.forEach((data, idx) => {
              let qid = summaryUrls[Object.keys(summaryUrls)[idx]]
              if (data.extract_html) entities[qid].summaryText = data.extract_html
              else if (data.extract) entities[qid].summaryText = data.extract
            })
          })
          .catch(err => console.error('Error fetching summaries:', err))
      }
      return entities
    }

    let referencedQIDs = collectQIDs()
    let entities = referencedQIDs.size ? await getEntityData(Array.from(referencedQIDs), props.language) : []
    const getEntity = (qid) => entities[qid] || {}

    for (const def of layerDefs) {
      if (def.qid) {
        let entity = getEntity(def.qid)
        if (entity) {
          def.label = entity.label
          def.description = entity.description
          def.thumbnail = entity.thumbnail
          def.coords = entity.coords
          def.geojson = entity.geojson
        }
      } else if (def.image && !def.coords) {
        let exifCoords = await getExifLocationFromUrl(fullUrl(def.image))
        if (exifCoords) def.coords = exifCoords
      }
      if (def.image && !def.thumbnail) {
        def.thumbnail = `${imageServiceUrl}/${fullUrl(def.image)}/w_300`
      }
      for (let [prop, value] of Object.entries(def)) {
        if (['allmaps', 'circle', 'label', 'id', 'description', 'thumbnail', 'coords', 'url'].includes(prop)) def[prop] = decodeURIComponent(value)
      }
      // if (def.layer) def.layerName = decodeURIComponent(def.layer)
    }
    console.log(layerDefs)

    const toGeoJSONLayer = (data) => {
      return L.geoJSON(data, {
        pointToLayer: (feature, _latlng) => {
          const _props = feature.properties
          let marker

          if (_props.type === 'marker' && _props.url) { // image marker
            let [width, height] = _props.size
              ? _props.size.split(',').map((item) => Number(item))
              : [100, 100]
            let style = `width:${width}px;height:${height}px;`
            if (_props.circle) style += `border-radius:50%;border:4px solid ${_props.color || '#555555'};`
            let imgUrl = _props.url.indexOf('wc:') === 0 ? mwImage(_props.url.slice(3), 108) : _props.url
            let img = `<img src="${imgUrl}" style="${style}"/>`
            marker = new L.Marker(_latlng, {
              icon: L.divIcon({
                html: img,
                className: 'image-icon', // Specify a class name we can refer to in CSS.
                iconSize: [52, 52] // Set a markers width and height.
              })
            })
          } else {
            let iconOptions = { ...markerIconTemplate }
            if (feature.properties.icon) iconOptions.iconUrl = feature.properties.icon
            if (feature.properties.shadowUrl) iconOptions.shadowUrl = feature.properties.shadowUrl
            if (feature.properties.iconRetinaUrl) iconOptions.iconRetinaUrl = feature.properties.iconRetinaUrl
            if (feature.properties.size) iconOptions.iconSize = _props.size.split(',').map((item) => Number(item))

            if (_props['markerType'] === 'circle' || _props['marker-symbol'] === 'circle') {
              let radius = _props.radius
                ? Number(_props.radius)
                : _props['marker-size']
                  ? _props['marker-size'] === 'small'
                    ? 8
                    : _props['marker-size'] === 'medium'
                      ? 16
                      : 32
                  : 4
              let color = _props['marker-color'] || '#2C84CB'
              let fillColor = _props['fill'] || color
              let weight = Number(_props['stroke-width']) || 0
              let stroke = weight > 0 ? true : false
              let options = { radius, fillColor, stroke, color, weight }
              marker = L.circleMarker(_latlng, options)
            } else {
              marker = L.marker(_latlng, { icon: new L.Icon(iconOptions) })
            }
          }
          return marker
        },
        onEachFeature: async (feature, layer) => {
          let fg = layer
          if (!feature.properties.coords) {
            if (fg.feature?.bbox) {
              let center = fg.getBounds().getCenter()
              feature.properties.coords = `${center.lat},${center.lng}`
            } else if (feature.geometry.type === 'Polygon') {
              let center = turf.centroid(feature)
              feature.properties.coords = `${center.geometry.coordinates[1]},${center.geometry.coordinates[0]}`
            }
          }

          // Bind popup
          if (feature.properties.qid || isQid(feature.properties.id)) {
            let qid = feature.properties.qid || feature.properties.id
            let entity = await getEntity(qid)
            let card = makeLocationCard(entity)
            layer.bindPopup(card.outerHTML)
          } else {
            let card = makeLocationCard(feature.properties)
            layer.bindPopup(card.outerHTML)
          }

          if (props.popupOnHover) {
            layer.on('mouseover', () => layer.openPopup())
            layer.on('mouseout', () => layer.closePopup())
          }

          layer.on('click', () => {
            layer.openPopup()
          })
        },
        style: (feature) => {
          const featureProps = feature?.properties
          // console.log(featureProps)
          const _geometry = feature?.geometry.type
          for (let [prop, value] of Object.entries(featureProps)) {
            if (value === 'null') featureProps[prop] = null
          }
          const style = {
            color: featureProps.color || '#FB683F',
            weight: featureProps.weight || (_geometry === 'Polygon' || _geometry === 'MultiPolygon' ? 0 : 4),
            opacity: featureProps.opacity || 1,
            fillColor: featureProps.fillColor || featureProps.fill || '#32C125',
            fillOpacity: featureProps.fillOpacity || 0.5,
          }
          return style
        }
      })
    }

    let layerControl
    const addLayerControl = (layer, name) => {
      if (!layerControl) layerControl = L.control.layers(Object.fromEntries([]), {}).addTo(map)
      layerControl.addOverlay(layer, name)
    }

    const initMap = async () => {

      let entity
      if (isQid(props.center)) {
        entity = await getEntity(props.center)
        center = L.latLng(entity.coords.split(',').map(c => parseFloat(c)))
        if (!props.caption) setCaption(entity.label)
      } else {
        center = L.latLng(props.center.split(',').map(c => parseFloat(c)))
      }
      zoom = props.zoom

      let _basemaps = (props.basemap).split(',').map(name => {
        let [url, options] = baseMapsConfigs[name]
        return [name.replace(/_/, ' '), L.tileLayer(url, options)]
      })

      let map = L.map('map', {
        gestureHandling: props.gestureHandling === true && !props['in-dialog'],
        preferCanvas: false,
        scrollWheelZoom: false, // disable original zoom function
        smoothSensitivity: 1.5,   // zoom speed. default is 1
        smoothWheelZoom: true,  // enable smooth zoom 
        zoomAnimation: true,
        zoomSnap: 0.1,
        layers: [_basemaps[0][1]]
      }).setView(center, zoom);

      if (_basemaps.length > 1) layerControl = L.control.layers(Object.fromEntries(_basemaps), {}).addTo(map)

      latLngZoom = `${Number((center.lat).toFixed(5))},${Number((center.lng).toFixed(5))},${zoom}`
      coords.textContent = latLngZoom
      map.on('click', (e) => {
        getLatLngZoom(e)
        let [lat, lng, zoom] = latLngZoom.split(',')
        copyTextToClipboard(`${lat},${lng}`)
      })
      map.on('movestart', () => { mapEl.style.cursor = 'move' })
      map.on('moveend', (e) => {
        mapEl.style.cursor = 'pointer'
        getLatLngZoom(e)
        coords.textContent = latLngZoom
      })

      return map
    }

    const markerIconTemplate = {
      iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-icon.png',
      iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-icon-2x.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      shadowSize: [41, 41]
    }

    const toGeoJSON = (locations) => {
      const data = { type: 'FeatureCollection', features: [] }
      locations.filter(location => location.coords)
        .forEach(location => {
          let [lat, lng] = location.coords.split(',').map(val => parseFloat(val.trim()))
          data.features.push({
            type: 'Feature',
            properties: location,
            geometry: { type: 'Point', coordinates: [lng, lat] }
          })
        })
      return data
    }

    const flyTo = async (locZoom) => {
      let split = locZoom.split(',')
      let entity, center, zoom
      if (isQid(split[0])) {
        entity = await getEntity(split[0])
        center = L.latLng(entity.coords.split(',').map(c => parseFloat(c)))
        zoom = split.length > 1 ? Number(split[1]) : 8
      } else if (split.length > 1) {
        center = L.latLng(split.slice(0, 2).map(c => parseFloat(c)))
        if (split.length > 2) zoom = parseFloat(split[2])
      }
      map.flyTo(center, zoom)
    }

    const warpedMapLayers = { value: [] }
    const addWarpedMap = (layer) => {
      let warpedMapLayer = new Allmaps.WarpedMapLayer(`https://annotations.allmaps.org/images/${layer.allmaps}`)
      warpedMapLayers.value.push({ name: decodeURIComponent(layer.name), layer: warpedMapLayer, opacity: layer.opacity || 100 })
      return warpedMapLayer
    }

    docReady(async function () {

      if (props.caption) setCaption(props.caption)
      main.style.visibility = 'visible'

      let mapAspectRatio = parseFloat(props.aspect || 1)
      windowAspectRatio = main.clientWidth / (main.clientWidth / mapAspectRatio + figcaption.clientHeight)
      window.parent.postMessage({ type: 'setAspect', aspect: windowAspectRatio }, '*');
      // document.querySelector('.size').innerHTML = `<span><b>Aspect ratio: </b></span> ${mapAspectRatio.toFixed(2)}`

      map = await initMap()

      if (layerDefs.length) {

        let markersByLayer = {}
        let geoJsonLayers = {}

        layerDefs.forEach(layerDef => {
          console.log(layerDef)
          if (layerDef.type === 'warped-map') {
            addWarpedMap(layerDef)
          } else if (layerDef.type === 'marker') {
            let layerName = layerDef.layer || 'locations'
            if (layerDef.preferGeojson && layerDef.geojson) {
              fetch(layerDef.geojson).then(resp => resp.json())
                .then(data => {
                  data.properties.qid = layerDef.id
                  let geoJsonLayer = toGeoJSONLayer(data)
                  addLayerControl(geoJsonLayer, layerDef.layerName || layerDef.label)
                  map.addLayer(geoJsonLayer)
                });
            } else {
              if (!markersByLayer[layerName]) markersByLayer[layerName] = []
              markersByLayer[layerName].push(layerDef)
            }
          } else if (layerDef.type === 'geojson' && layerDef.url) {
            if (layerDef.url.indexOf('http') !== 0) {
              if (layerDef.url[0] === '/') {
                let [owner, repo, branch, ...path] = props.ghbase.split('/')
                layerDef.url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}${layerDef.url}`
              } else {
                layerDef.url = `https://raw.githubusercontent.com/${props.ghbase}/${layerDef.url}`
              }
            }
            fetch(layerDef.url).then(resp => resp.json())
              .then(data => {
                let geoJsonLayer = toGeoJSONLayer(data)
                addLayerControl(geoJsonLayer, layerDef.layerName || layerDef.label || layerDef.url.split('/').pop().split('.').shift().replace(/[_-]/g, ' ').replace(/^./, c => c.toUpperCase()))
                map.addLayer(geoJsonLayer)
              });
          }
        })
        Object.keys(markersByLayer).forEach(layerName => {
          let layer = markersByLayer[layerName]
          let geoJsonLayer = toGeoJSONLayer(toGeoJSON(layer))
          addLayerControl(geoJsonLayer, layerName)
          map.addLayer(geoJsonLayer)
        })

        const opacityLayers = {}
        warpedMapLayers.value?.forEach(layer => {
          addLayerControl(layer.layer, layer.name)
          if (!layer.disabled) map.addLayer(layer.layer)
          opacityLayers[layer.name] = layer.layer
        })

        if (Object.keys(opacityLayers).length > 0) {
          let opacityControl =
            L.control.opacity(opacityLayers, {
              label: null,
              collapsed: true,
              position: 'topright' // topleft or topright or bottomleft or bottomright
            })
          opacityControl.addTo(map)
          Array.from(opacityControl.getContainer().querySelectorAll('.leaflet-control-layers-overlays label'))
            .forEach((overlay) => {
              let label = overlay.children[0].textContent.trim()
              let warpedMapLayer
              warpedMapLayers.value?.forEach(item => {
                if (item.name === label) warpedMapLayer = item
              })
              if (warpedMapLayer) {
                let startingOpacity = warpedMapLayer.opacity
                let rangeControl = overlay.children[1].children[0]
                rangeControl.value = startingOpacity
                warpedMapLayer.layer.setOpacity(startingOpacity / 100)
                rangeControl.addEventListener('input', (evt) => {
                  evt.preventDefault()
                  evt.stopPropagation()
                  warpedMapLayer.layer.setOpacity(parseInt(rangeControl.value) / 100)
                })
              }
            })
        }
      }

    })

  </script>
</body>

</html>